# -*- coding: utf-8 -*-
"""
Created on Tue Oct 12 18:02:13 2021

@author: Quentin
"""
# To simulate the discovery of blocks it generates random numbers
import random
from matplotlib.figure import Figure 
from matplotlib.backends.backend_tkagg import (FigureCanvasTkAgg, NavigationToolbar2Tk) 
from tkinter import *

'''
simulateSatoshiAttack : function to simulate the Satoshi's attack (Double Spending Attack)
z_input_nbConfirmations [IN] : The number of confirmations for the transaction
q_input_relativeHashrateOfAttacker [IN] : The relative hashrate of the attacker
v_input_doubleSpendAmount [IN] : the amount of the double spend 
A_input_maximumAuthorizedDelay [IN] : The maximum delay authorized between the official blockchain and the attacker chain
n_input_nbCycles [IN] :  The number of cycles in the attack
'''

def simulateSatoshiAttack(z_input_nbConfirmations, q_input_relativeHashrateOfAttacker, v_input_doubleSpendAmount,
                          A_input_maximumAuthorizedDelay, n_input_nbCycles):

    # The number of cycles in the attack
    nbCycles = 0
    # The number of cycles won by the attacker
    output_number_of_cycles_won_per_attack = 0
    # This counter represents the duration of the attack
    attackDurationCounter = 1 / q_input_relativeHashrateOfAttacker
    # The total revenue of the attack
    total_revenue_of_attack = 0
    number_of_blocks_mined_in_attack = 0

    # Until we have done all the cycles
    while nbCycles < n_input_nbCycles:

        # The number of cycles in the attack
        nbCycles = nbCycles + 1
        # Represents the number of blocks found by the attacker
        counterAttacker = 0
        # Represents the number of blocks found by the honest miner
        counterHonestMiner = 0

        # ---------------------------------------- PHASE 0 -------------------------------------------------------------

        # The attacker has premined 1 block, we do not simulate this phase

        # ---------------------------------------- PHASE 1 -------------------------------------------------------------

        # At the end of this phase the merchant sends the consumer goods to the attacker
        while True:

            # This counter represents the attack
            attackDurationCounter = attackDurationCounter + 1
            # To simulate the discovery of blocks it generates random numbers
            randomNumber = (random.randint(1, 100)) / 100

            if q_input_relativeHashrateOfAttacker >= randomNumber:
                counterAttacker = counterAttacker + 1
            else:
                counterHonestMiner = counterHonestMiner + 1

            # The delay between the official blockchain and the attacker chain
            delay = counterHonestMiner - counterAttacker

            if counterHonestMiner >= z_input_nbConfirmations or delay >= A_input_maximumAuthorizedDelay + 1:
                break

        # If the attacker has not exceeded or equalized the size of the official blockchain
        if counterAttacker < counterHonestMiner and delay < A_input_maximumAuthorizedDelay:

            # ---------------------------------------- PHASE 2 -------------------------------------------------------------

            # As long as the 2 conditions are fulfilled
            # condition 1 : The delay is smaller than the maximum allowed
            # condition 2 : The counter of the attacker is smaller or equal to that of the honest minors
            # The attacker has already premined 1 block, so we stop when his block number is equal to that of the official blockchain

            while True:

                # This counter represents the duration of the attack
                attackDurationCounter = attackDurationCounter + 1

                # To simulate the discovery of blocks it generates random numbers
                randomNumber = (random.randint(1, 100)) / 100

                if q_input_relativeHashrateOfAttacker >= randomNumber:
                    counterAttacker = counterAttacker + 1
                else:
                    counterHonestMiner = counterHonestMiner + 1

                # The delay between the official blockchain and the attacker chain
                delay = counterHonestMiner - counterAttacker

                if delay >= A_input_maximumAuthorizedDelay + 1 or counterAttacker >= counterHonestMiner:
                    break

        # If the attacker has exceeded the size of the official blockchain
        if counterAttacker >= counterHonestMiner:
            # The number of cycles won by the attacker
            output_number_of_cycles_won_per_attack = output_number_of_cycles_won_per_attack + 1
            # The revenue generated by the blocks mined by the attacker
            revenue_blocks_mined = counterAttacker
            # The attacker's revenue :  (the mined blocks revenue + double spend amount) / the duration of the attack
            total_revenue_of_attack = total_revenue_of_attack + revenue_blocks_mined + v_input_doubleSpendAmount

            number_of_blocks_mined_in_attack = number_of_blocks_mined_in_attack + counterAttacker

    # The attacker revenue ratio, it's the income divided by the duration it takes to get the income
    output_revenueRatioAttacker = total_revenue_of_attack / attackDurationCounter
    return output_revenueRatioAttacker


def resultDoubleSpending(fenetre, z_input_nbConfirmations, q_input_relativeHashrateOfAttacker, v_input_doubleSpendAmount,
                        A_input_maximumAuthorizedDelay, n_input_nbCycles):

    z_input_nbConfirmations = float(z_input_nbConfirmations.get())
    q_input_relativeHashrateOfAttacker = float(q_input_relativeHashrateOfAttacker.get())
    v_input_doubleSpendAmount = float(v_input_doubleSpendAmount.get())
    A_input_maximumAuthorizedDelay = float(A_input_maximumAuthorizedDelay.get())
    n_input_nbCycles = float(n_input_nbCycles.get())

    result = simulateSatoshiAttack(z_input_nbConfirmations, q_input_relativeHashrateOfAttacker, v_input_doubleSpendAmount, A_input_maximumAuthorizedDelay, n_input_nbCycles)

    label = Label(fenetre, text="Revenue ratio attacker : "+str(result))
    label.grid(column=0, row=6)

    y = []
    for i in range(1, 51):
        y.append(simulateSatoshiAttack(z_input_nbConfirmations, i/100, v_input_doubleSpendAmount, A_input_maximumAuthorizedDelay, n_input_nbCycles))
    

    fig = Figure(figsize = (5, 5), 
                 dpi = 100) 
    
    plot1 = fig.add_subplot(111) 
  
    
    plot1.plot(y)  
    
    canvas = FigureCanvasTkAgg(fig, 
                               master = fenetre)   
    canvas.draw() 
  
    canvas.get_tk_widget().grid(column=0, columnspan=2, row=7)

# print(simulateSatoshiAttack(2, 0.5, 1, 3, 1000))